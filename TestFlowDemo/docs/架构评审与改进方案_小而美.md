# 架构评审与改进方案（小而美 / 瑞士军刀）

本文从“配置驱动、单体可维护、可验证、低耦合”的目标出发，对现状做重点评审并提出可落地的小步改进路线，避免过度工程化。

## 一、现状速览

- 分层清晰：`ConfigManager`（加载流程/设备）、`WorkflowCore` + `StepBodies`（执行与路由）、`DeviceFactory`（设备池化与互斥）、`ResultEvaluator`（判定）、`ParamInjector`（参数注入缓存）、`DatabaseService`（SQLite 持久化）。
- 能力可用：子流程与子流程引用（`SubflowRegistry`）、参数从 DB 注入（TTL/手动刷新）、设备健康检查（`IHealthyDevice`）、对象池优化（`StepResultPool`）。
- 配置与示例完整：`Flows/*.json` + `Flows/Subflows/*.json`、`Devices.json`、`docs/*` 文档。

## 二、主要问题与风险点（按优先级）

1. 数据表结构不一致

- `DatabaseService.InitDb()` 与 `Storage/Entities.sql`、`GetAllActiveParams()` 所期望字段不一致（`line/station_no/model/step_name/param_json/status`）。
- 影响：参数注入可能读取不到/写入失败；上线后易产生“表结构漂移”。

2. 步骤级超时未被统一执行

- `StepConfig.TimeoutMs` 未在设备执行层形成一致约束，仅有总流程超时（`TestRunner`）。
- 影响：单步卡死会拖垮整次测试；与设备实现强耦合。

3. 设备工厂硬编码映射&实现混杂

- `DeviceFactory.CreateInternal` 大量 if/else；Mock 与真实设备混在 `MockDevices.cs`。
- 影响：扩展性与可读性差；不利于小步演进。

4. 结果判定实现重复

- `ResultEvaluator` 与 `ResultEvaluatorV1` 共存，规则/容错略有差异。
- 影响：理解与维护成本升高，易出现行为不一致。

5. 流程配置前置校验不足

- `OnSuccess/OnFailure` 指向是否存在、`SubFlowRef` 是否可解析等，均在运行时才暴露问题。

## 三、改进原则

- 最小可行：优先修复一致性与稳定性；少引入新概念。
- 配置优先：功能开关与参数尽量落入 JSON/DB。
- 单一二进制：不做插件扫描，不做远程服务化；保留“瑞士军刀”属性。

## 四、分阶段落地方案

A. 本周（修复与加固）

- 统一 DB Schema（高优先）
  方案:按 `Entities.sql` 更新 `InitDb()` 内建表语句，确保与 `GetAllActiveParams()` 字段一致。
- 移除/废弃 `ResultEvaluatorV1`，全量切至 `ResultEvaluator`；在 `docs/TestFramework_Documentation.md` 标注唯一支持的规则与示例。
- 拆分设备文件：将真实设备（如 `ResistorBoxDevice`、`VoltmeterDevice`）从 `MockDevices.cs` 拆到独立文件（`Devices/Real/*`），Mock 留在 `Devices/Mock/*`。

B. 下周（体验与一致性）

- 统一步骤级超时
  - 在 `DeviceExecStep` 与 `SubFlowExecutor` 中根据 `TimeoutMs` 创建 `CancellationTokenSource.CreateLinkedTokenSource(AppServices.Context.Token)`，传入 `StepContext`/设备；对超时统一写 Step 记录并 `pooledResult.Success=false`。
  - 设备实现若不支持取消，至少在超时后中止后续步骤并记录原因。
- 设备注册表最小化重构
  - 将 `DeviceFactory` 的 if/else 改为 `Dictionary<string, Func<DeviceConfig, IDevice>>` 注册表；默认注册现有类型，保留 `Register(type, factory)` 扩展点（无需插件扫描）。
- 流程预校验
  - 在 `ConfigManager.GetFlowConfig()` 加一次验证：校验 `DependsOn`/`OnSuccess`/`OnFailure` 存在性、检测死链、验证 `SubFlowRef` 是否可解析；校验失败立即抛错并在 UI 给出明确提示。

C. 以后（按需演进，保持克制）

- 传输层抽象（仅当新增设备需要时）
  - 最小 `ITransport`（`Send`/`Receive`/`Open`/`Close`），串口/Socket 由适配器实现；先不做插件化与反射加载。
- 观测性小增强
  - 日志补充步骤耗时与关键参数快照（UI 已有日志，DB 已记录时间；仅追加 UI 侧耗时显示）。

## 五、目录与命名建议（不强制）

- `Devices/Mock/*` 与 `Devices/Real/*` 分类；`DeviceFactoryRegistry.cs` 存放注册表。
- 继续使用 `Devices.json`（保持兼容），后续有需要再统一成小写。

## 六、落地清单（任务→修改点）

- Schema 统一：`Storage/DatabaseService.cs`（InitDb/表结构）+ 使用 `Entities.sql`；回归测试：参数注入/步骤写入。
- 步骤超时：`Workflow/StepBodies.cs` 两处调用设备的封装；`Devices/*` 适配可取消或超时返回。
- 工厂注册表：`Devices/DeviceFactory.cs`；新增 `Devices/DeviceFactoryRegistry.cs`（或合并）。
- 判定统一：删除 `Engine/ResultEvaluatorV1.cs` 的调用路径（文件可暂保留，标注弃用）。
- 预校验：`ConfigManager.cs` 新增 `ValidateFlow(FlowConfig cfg)` 并在 `GetFlowConfig` 末尾调用。

> 以上改动均为小步、内聚、可回退的重构，保持单进程、单二进制与配置驱动，满足快速落地与长期可维护性。
