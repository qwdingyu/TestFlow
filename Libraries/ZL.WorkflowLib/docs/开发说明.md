# 关于工作流简要说明

```
目前有两种模式：
1、简单模式-自定义json，json中包含 OnSuccess、OnFailure、 DependsOn
通过DependsOn 确定是否可以开始流程；

2、直接使用workflowcore模式；
workflowcore 不支持 DependsOn；具体见如下分析

```


#### 目前开源的 WorkflowCore 在核心模型中只有“步骤 + 出边（Outcomes）”的概念，默认 DSL 里既没有 DependsOn 字段，也没有内建的多前驱 Join 语义，因此无法同时满足“OnSuccess/OnFailure 分支 + 多前驱依赖全部完成后再启动”的需求。
OnSuccess/OnFailure 本质上都被编译成 WorkflowStep.Outcomes 里的出边；当同一个目标步骤既由 NextStep（成功）指向，又由自定义 DependsOn 额外添加出边时，就会触发重复边的校验提示，体现为“依赖只是多余的出边”，并不会形成真正的“等待多个前驱”的效果。
引擎在步骤完成时立即为所有匹配的出边创建新的执行指针（ExecutionPointer），而指针只记录单个 PredecessorId，也没有统计其它前驱是否完成，因而天然不支持 DAG 里常见的 Join/同步场景。
代码中虽然存在 PendingPredecessor 状态，但目前只在补偿（Compensation）流程里串联补偿步骤时使用，并未扩展成“等待多前驱”的通用机制。

### 代码分析
1. DSL/模型层
- StepSourceV1 仅支持 NextStepId 与 SelectNextStep 这类出边配置，不存在 DependsOn，所以 DynamicWorkflow 若支持 DependsOn，只能自己把它翻译成额外的出边，无法在框架层记录“我还要等另外几个前驱”。

2. 执行管线
- ExecutionResultProcessor 在步骤成功时遍历 step.Outcomes，对每个满足条件的出边调用 ExecutionPointerFactory.BuildNextPointer 立刻生成新的执行指针，指针的 PredecessorId 只保存当前这条出边来源指针的 Id。

3. 执行指针结构
- ExecutionPointer 只有一个 PredecessorId 属性，也没有任何集合去追踪“还有哪些前驱没结束”。因此当某个步骤需要多个前驱时，框架缺乏决定“什么时候可以激活该指针”的依据。

4. 补偿逻辑的启示
- 补偿处理器把后续补偿指针标记为 PendingPredecessor 并串联 PredecessorId，说明框架支持“先生成指针，等待特定前驱结束后再激活”。这一机制可以借鉴到未来的 Join 扩展中。

### 为什么当前无法同时支持 DependsOn 与 OnSuccess/OnFailure
- OnSuccess/OnFailure 在实现层都是“额外的出边”。ValueOutcome.Matches 的逻辑决定了只要 ExecutionResult.OutcomeValue 匹配或为 null，出边就会被触发，因此 OnSuccess 与 OnFailure 可以共存，但它们只会增加出边数量。
- 当 DynamicWorkflow 再把 DependsOn 转成“从所有前驱到该步骤的额外出边”时，就会与 OnSuccess/OnFailure 的出边发生重复，触发 DSL 装载时的重复校验，却仍无法实现“等多个前驱全部完成后再启动”。
- 由于没有 Join 语义，同一个目标步骤会被多次激活，每次都只知道一个 PredecessorId，不会等待其它依赖，导致真正的 DAG 同步场景无法表达。

### 改造思路（让 DependsOn + OnSuccess/OnFailure 共存）
1.模型层扩展
- 在 StepSourceV1 增加 DependsOn 列表，并在 DefinitionLoader 建表时把它解析成步骤内部的新属性（例如 WorkflowStep.DependsOnStepIds）。
- 保留现有的 Outcomes，让 OnSuccess/OnFailure 仍通过出边表达，从而兼容现有流程。

2. 执行指针管理
- 修改 ExecutionResultProcessor：在准备创建目标步骤指针时，先检查该步骤的 DependsOnStepIds。
- 若该步骤尚未创建执行指针，则创建一个指针但将其标记为 PendingPredecessor，并在 ExtensionAttributes 中记录已满足的前驱集合。
- 每当另外一个依赖前驱完成时，查找对应指针，把该前驱记入集合；只有当集合包含了全部依赖，才把指针状态改成 Pending 并激活。

3. 重复创建保护
- 在 ExecutionResultProcessor 中避免重复生成同一个步骤的指针（可通过查找同 StepId 且尚未执行完成的指针实现）。

4. 错误处理与补偿
- 若需要保证补偿、取消等场景仍然正确，要同步考虑 Join 指针在异常/补偿时的处理方式，使其与 PendingPredecessor 的现有用法兼容。

5. DSL 兼容性
- 解析新字段后仍应允许只写 OnSuccess/OnFailure 的线性流程；当 DependsOn 为空时不触发新的等待逻辑，从而保持兼容。


### 实现难度评估与建议
- 复杂度评估：中等偏高
- 需要修改 DSL 模型、定义加载器、执行结果处理器以及执行指针的数据结构（虽然可以利用 ExtensionAttributes 避免破坏序列化格式，但仍需充分测试）。同时必须保证补偿、事件等待、并行分支等现有能力不被破坏。

### 建议的推进步骤
- 先在单元测试中构造最小的 DAG Join 场景（两个前驱指向一个合并步骤），通过失败用例刻画现状。
- 按上述思路扩展模型和执行管线，实现“依赖全部满足后激活”的逻辑。
- 增加更多测试覆盖 OnSuccess/OnFailure、错误补偿、并行分支等组合情况，确保无回归。
- 若担心影响面过大，可优先在自定义 Fork 的分支里实现，再根据稳定情况考虑 upstream PR。
- 通过上述改造，WorkflowCore 即可同时支持“出边（OnSuccess/OnFailure）”与“多前驱依赖（DependsOn）”，真正落地 DAG/Join 语义，同时保持原有线性流程的兼容性。
